<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="말로 하는 레시피, 요리할 때 편리한 웹사이트. 음성 명령으로 조작하는 요리 레시피 제공.">
    <title>요리 레시피</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/3.0.23/tailwind.min.css">
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; transition: background-color 0.3s ease; }
        .recipe-container { max-width: 600px; margin: auto; padding: 20px; background: white; }
        .controls input { width: 60px; text-align: center; }
        .instructions li { padding: 10px; border-bottom: 1px solid #ddd; }
    </style>
</head>
<body>
    <div class="recipe-container p-6 rounded-lg shadow-lg">
        <h1 id="recipe-title" class="text-2xl font-bold">레시피 로딩 중...</h1>
        <div class="controls my-4 flex items-center space-x-2">
            <label class="font-semibold">인분 수:</label>
            <input type="number" id="servings" value="2" min="1" class="border rounded px-2 py-1">
        </div>
        <h2 class="text-xl font-semibold">재료</h2>
        <ul id="ingredient-list" class="ingredient-list mt-2"></ul>
        <h2 class="text-xl font-semibold mt-4">조리 방법</h2>
        <ul id="instructions" class="instructions mt-2"></ul>
        <h2 class="text-lg font-semibold mt-4">총 칼로리: <span id="total-calories">0</span> kcal</h2>
    </div>

   <script>
    let recipes = {};
    let currentRecipe = "seaweedsoup";
    let waitingForTimerInput = false; // 타이머 시간 입력 대기 상태 변수
    let ttsAllowed = true;

    // 모바일(터치 지원) 환경이면 터치/클릭 전까지 ttsAllowed = false
    function isMobileDevice() {
        return (
            'ontouchstart' in window ||
            navigator.maxTouchPoints > 0 ||
            navigator.msMaxTouchPoints > 0
        );
    }
    if (isMobileDevice()) {
        ttsAllowed = false;
        document.body.addEventListener('touchstart', () => { ttsAllowed = true; }, { once: true });
        document.body.addEventListener('mousedown', () => { ttsAllowed = true; }, { once: true });
    }

    async function loadRecipes() {
        const response = await fetch('recipes.json');
        recipes = await response.json();
        // 마지막으로 본 레시피를 localStorage에서 불러옴, 없으면 기본값
        currentRecipe = localStorage.getItem("lastRecipe") || "seaweedsoup";
        const savedServings = localStorage.getItem("servings") || recipes[currentRecipe].servings;
        document.getElementById("servings").value = savedServings;
        renderRecipe(savedServings);
    }

    function renderRecipe(servings) {
        // 레시피 변경 시 localStorage에 저장
        localStorage.setItem("lastRecipe", currentRecipe);
        document.getElementById("recipe-title").textContent = recipes[currentRecipe].name;
        document.body.style.backgroundColor = recipes[currentRecipe].color || "#f8f8f8";
        updateIngredients(servings);
        renderInstructions();
        startVoiceRecognition();
    }

    function updateIngredients(servings) {
        localStorage.setItem("servings", servings);
        const ingredientList = document.getElementById("ingredient-list");
        ingredientList.innerHTML = "";
        let totalCalories = 0;

        recipes[currentRecipe].ingredients.forEach(ingredient => {
            const adjustedAmount = (ingredient.amount / recipes[currentRecipe].servings) * servings;
            let caloriesPerGram = ingredient.calories_per_unit;
            if (ingredient.unit === 'g' && caloriesPerGram > 20) { // 100g당 kcal로 추정되는 값
                caloriesPerGram = caloriesPerGram / 100;
            }
            totalCalories += adjustedAmount * (caloriesPerGram || 0);
            const li = document.createElement("li");
            li.textContent = `${ingredient.name}: ${adjustedAmount.toFixed(1)} ${ingredient.unit}`;
            ingredientList.appendChild(li);
        });

        document.getElementById("total-calories").textContent = totalCalories.toFixed(1);
    }

    function renderInstructions() {
        const instructionsList = document.getElementById("instructions");
        instructionsList.innerHTML = "";
        recipes[currentRecipe].instructions.forEach(step => {
            const li = document.createElement("li");
            li.textContent = `${step.step}. ${step.description}`;
            // 이미지 추가를 try-catch로 감싼다
            try {
                const img = document.createElement("img");
                img.src = `images/${currentRecipe}/${step.step}.png`;
                img.alt = `Step ${step.step} image`;
                img.classList.add("instruction-image");
                img.onerror = () => {
                    if (img.parentNode) img.parentNode.removeChild(img);
                };
                li.appendChild(img); // li 내부에 이미지 추가
            } catch (e) {
                // 이미지 추가 중 오류가 발생해도 무시
                console.error("이미지 추가 중 오류:", e);
            }
            instructionsList.appendChild(li);
        });
    }

    document.getElementById("servings").addEventListener("input", function() {
        updateIngredients(this.value);
    });

    function startVoiceRecognition() {
        const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
        recognition.lang = "ko-KR";
        recognition.continuous = true;
        recognition.interimResults = false;

        recognition.onresult = function(event) {
            const lastResult = event.results[event.results.length - 1][0].transcript.trim();
            handleVoiceCommand(lastResult);
        };
        recognition.onend = function() {
            recognition.start();  // 계속 음성 인식이 진행되도록 설정
        };

        recognition.start();
    }

    function handleVoiceCommand(command) {
        if (waitingForTimerInput) {
            // 시간 입력만 들어왔을 때 타이머 설정
            const timeInfo = extractTime(command);
            if (timeInfo) {
                speak(`${timeInfo.label} 타이머를 시작합니다`);
                setTimeout(() => {
                    speak(`${timeInfo.label}이 경과했습니다. 다음 스탭을 진행하세요`);
                }, timeInfo.ms);
                waitingForTimerInput = false;
            } else {
                speak("시간을 다시 말씀해 주세요. 예: 3분, 30초, 1시간");
            }
            return;
        }
        if (command.includes("다음") || command.toLowerCase().includes("next") || command.includes("샤이꺼꺼")) {
            window.scrollBy({ top: window.innerHeight * 0.8, behavior: "smooth" });
        } else if (command.includes("이전") || command.toLowerCase().includes("previous") || command.includes("샹이꺼")) {
            window.scrollBy({ top: -window.innerHeight * 0.8, behavior: "smooth" });
        } else if (command.includes("인분")) {
            const match = command.match(/(\d+)인분/);
            if (match) {
                document.getElementById("servings").value = match[1];
                updateIngredients(match[1]);
                speak(`${match[1]}인분으로 변경되었습니다.`);
            }
        } else if (command.includes("타이머") || command.includes("알림")) {
            // 현재 스텝 찾기 (화면에 보이는 첫 번째 스텝 기준)
            const instructions = recipes[currentRecipe].instructions;
            let currentStep = 0;
            for (let i = 0; i < instructions.length; i++) {
                const stepElement = document.querySelectorAll("#instructions li")[i];
                if (stepElement && stepElement.getBoundingClientRect().top > 0) {
                    currentStep = i;
                    break;
                }
            }
            const stepText = instructions[currentStep].description;
            const timeInfo = extractTime(stepText);
            if (timeInfo) {
                speak(`${timeInfo.label} 타이머를 시작합니다`);
                setTimeout(() => {
                    speak(`${timeInfo.label}이 경과했습니다. 다음 스탭을 진행하세요`);
                }, timeInfo.ms);
            } else {
                speak("몇 분 타이머를 설정할까요?");
                waitingForTimerInput = true;
            }
        } else {
            for (let key in recipes) {
                if (command.includes(recipes[key].name)) {
                    currentRecipe = key;
                    renderRecipe(localStorage.getItem("servings") || recipes[currentRecipe].servings);
                    speak(`${recipes[key].name} 레시피로 변경되었습니다.`);
                    break;
                }
            }
        }
    }

    function speak(text) {
        try {
            if (!ttsAllowed) return; // 모바일에서 터치/클릭 전에는 TTS 실행 안함
            const utter = new SpeechSynthesisUtterance(text);
            utter.lang = "ko-KR";
            window.speechSynthesis.speak(utter);
        } catch (e) {
            // TTS가 안되어도 무시하고 다른 기능은 정상 동작
            console.warn('TTS 실행 오류:', e);
        }
    }

    function extractTime(text) {
        // "3분", "30초", "1시간" 등 패턴 추출
        const minuteMatch = text.match(/(\d+)\s*분/);
        const secondMatch = text.match(/(\d+)\s*초/);
        const hourMatch = text.match(/(\d+)\s*시간/);

        let ms = 0;
        if (hourMatch) ms += parseInt(hourMatch[1]) * 60 * 60 * 1000;
        if (minuteMatch) ms += parseInt(minuteMatch[1]) * 60 * 1000;
        if (secondMatch) ms += parseInt(secondMatch[1]) * 1000;

        if (ms > 0) {
            let label = "";
            if (hourMatch) label += `${hourMatch[1]}시간 `;
            if (minuteMatch) label += `${minuteMatch[1]}분 `;
            if (secondMatch) label += `${secondMatch[1]}초`;
            return { ms, label: label.trim() };
        }
        return null;
    }

    window.onload = loadRecipes;
    </script>
</body>
</html>
